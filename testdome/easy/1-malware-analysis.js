`
Reference: https://www.testdome.com/library?page=1&skillArea=31&questionId=108075

QUESTION (Malware Analysis)
--------

Difficulty: EASY

Your company is analyzing malware which targets numerical record files.
The malware uses a sliding window over the array of numbers in a file, and tries to match the following pattern:
Tl, -, -, X, -, -, -, Tr
The entire window is moved so that 'X' passes through all the values and is compared to the numbers at the 'T!' and 'Tr' locations, which are positioned at a constant offset to 'X.
The malware has the following rules:

    • If the value at the 'Tl' or 'Tr' position of the pattern is bigger or equal to the value at the 'X' position, the malware replaces the value at 'X' with 0.
    • If the value at the 'T!' or 'Tr' offset is out of bounds, then the value at 'X' is only compared to the other existing value.
    • The record is processed in two stages: first, all the positions that should be set to 0 are located, using the original values for comparison. Only after all positions have been identified do they get set to 0.

    For example, if the values in a record file are the following:

[1, 2, 0, 5, 0, 2, 4, 3, 3, 3]

The expected values after the malware runs are:

[1, О, О, 5, 0, 0, 0, 3, 3, 0]

In this example, both 2's, the '4' and the last '3' were replaced by 0.
Implement the simulate function so that the malware behavior is replicated for further study.

`;

`
SOLUTION
--------


`;

function simulate(arr) {
  const arrCopy = [...arr]; // copy the original array
  const tempArr = []; // indices of elements to replace by 0 will be store here

  // checking using the rightOffset
  for (let i = 0; i < arrCopy.length; i++) {
    const indiceX = arrCopy[i];
    let rightOffset;

    if (i >= arrCopy.length - 4) {
      // // X is close enough to the end (no right offset)
    } else {
      rightOffset = i + 4;
      // Compare X with the rightOffset position, add to tempEntries if condition met
      if (indiceX <= arrCopy[rightOffset]) {
        tempArr.push(i);
      }
    }
  }

  // checking using the leftOffset
  for (let i = 0; i < arrCopy.length; i++) {
    const indiceX = arrCopy[i];
    let leftOffset = i;

    if (leftOffset <= 2) {
      // X is close enough to the beginning (no left offset)
    } else {
      leftOffset = i - 3;
      // Compare X with the leftOffset position, add to tempEntries if condition met
      if (indiceX <= arrCopy[leftOffset]) {
        tempArr.push(i);
      }
    }
  }

  // Replace elements at positions stored in tempEntries with 0
  for (let i = 0; i < arrCopy.length; i++) {
    if (tempArr.includes(i)) {
      arrCopy[i] = 0;
    }
  }

  return arrCopy; // return the modified array
}

// Example usage:
const result = simulate([1, 2, 0, 5, 0, 2, 4, 3, 3, 3]);
console.log(result.join(" "));
// Expected output: 1 0 0 5 0 0 0 3 3 0

// output: [ 1, 0, 0, 5, 0, 0, 0, 3, 3, 0 ]

`
SOLUTION 2

`;

function simulate(entries) {
  let result = new Array(entries.length);

  for (let i = 0; i < entries.length; i++) {
    let x = entries[i];
    let tl = i - 3 >= 0 ? entries[i - 3] : Number.MIN_SAFE_INTEGER;
    let tr = i + 4 < entries.length ? entries[i + 4] : Number.MIN_SAFE_INTEGER;

    if (tl >= x || tr >= x) {
      result[i] = 0;
    } else {
      result[i] = x;
    }
  }

  return result;
}
